Function autorisée explications : 

Open : Prototype : int	open(const char *pathname, int flags, mode_t mode);
	   Usage : Ouvrir des fichiers en mode lecture, ecriture ou les deux.
	   Exemple : int	fd = open("file.txt", O_RDONLY);


Close : Usage : Ferme un descripteur de fichier apres l'avoir utiliser.
		Prototype : int	close(int fd);
		Exemple : close(fd);


Read : Usage : Utiliser pour lire les donnees depuis un fichier ou un pipe. La fonction renvoie le nombre d'octets lus.
	   Prototype : ssize_t	read(int fd, void *buf, size_t count);
	   Exemple : char	buffer[100];
	   					ssize_t bytesRead = read(fd, buffer, 100);


Write : Usage : Utiliser pour écrire dans un fichier, un pipe, ou sur la sortie standard/erreur.
		Prototype : ssize_t	write(int fd, const void *buf, size_t count)
		Exemple : write(fd, "Hello", 5);


Malloc : Usage : Utiliser pour allouer une certaines quantité de mémoire pour pouvoir travailler dynamiquement.
		 Prototype : void	*malloc(size_t size);
		 Exemple : int	*arr = malloc(sizeof(int) * 10);


Free : Usage : Utiliser pour libérer de la mémoir allouer dynamiquement pour éviter les fuites de mémoire.
	   Prototype : void	free(void *ptr);
	   Exemple : free(arr);


Perror : Usage : Affiche un message d'erreur basé sur la variable errno, en gros affiche un message d'erreur
					avec une description textuelle en cas d'échec.
		 Prototype : void perror(const char *s);
		 Exemple : perror("Erreur lors de l'ouverture du fichier");
		 la variable errno est une variable globale qui contient le dernier code erreur défini par une fonction systeme.
		 donc dans notre cas, perror("Erreur lors de l'ouverture du fichier");
		 					  cela va afficher : Erreur lors de l'ouverture du fichier: No such file or directory


pour pouvoir utiliser errno il faut ce header : #include <errno.h>
La nuance entre les deux fonction est que Perror se sert de strerror pour afficher le message d'erreur apres le message voulu
alors que strerror renvoi simplement l'erreur associé.


strerror : Usage : Renvoi une chaine de caractere d'écrivant l'erreur associé a un code erreur errno.
		   Prototype : char *strerror(int errnum);
		   Exemple : printf("Erreur : %s\n", strerror(errno));


Access : Usage : Vérifie si un fichier existe et si l'utilisateur a les droits nécessaires pour l'utiliser.
		 Prototype : int access(const char *pathname, int mode);
		 Exemple :	if (access("file.txt", F_OK) == -1)
		 			{
						perror("le fichier n'existe pas");
					}
		 Header : #include <unistd.h>
		 pathname : il s'agit du chemin du fichier ou du répertoire a tester.
		 mode : Ce parametre spécifie le type de test a effectuer, ce sont des constantes de <fcntl.h> ou <unistd.h>
		 F_OK = Vérifie si le fichier existe.
		 R_OK = Vérifie si le fichier est accessible en lecture.
		 W_OK = Vérifie si le fichier est accessible en écriture.
		 X_OK = Vérifie si le fichier est exécutable.
		 Valeur de retour : 0 = la fonction réussi donc que le fichier ou repertoire est accessible.
		 Valeur de retour = -1 = la fonction a échoué, donc que le fichier ou repertoire n'est pas accessible.
		 cette fonction renvoi une erreur errno si cela echoue.
		 nous pouvons combiner les test : if (access("file.txt", F_OK | R_OK | W_OK | X_OK) == -1)

Dup : Usage : Crée une copie d'un descripteur de fichier.
	  Prototype : int dup(int oldfd);
	  Exemple : int new_fd = duf(oldfd);
	  Si une erreur surivient elle return -1 et errno peut indiquer l'erreur.
	  ATTENTION, les deux fd pointent au meme endroit, donc la modification d'un entraine la modification de l'autre.
	  prend le plus petit fd de libre.

Dup2 : Usage : Utiliser pour rediriger un descripteur de fichier vers un autre. Par Exemple rediriger
				la sortie standard (stdout) vers un fichier.
	   Prototype : int	dup2(int oldfd, int newfd);
	   Exemple : dup2(fd, STDOUT_FILENO);
	   Dup2 est comme dup sauf que on peut préciser quel fd on veut utiliser pour la redirection.
	   dans notre exemple, si fd était déja ouvert, il sera fermé pour pouvoir dupliquer la sortie standard.


Execve : Usage : Remplace le processus courant par un autre programme. En gros, execute un programme en remplacant le
					processus courant. C'est souvent utiliser pour lancer un progranne avec des variables d'environnement.
		 Prototype : int execve(const char *pathname, char *const argv[], char *const envp[]);
		 Exemple : execve("/bin/ls", args, env);
		 La fonction execve est une des plus importantes du systeme Unix/Linux
		 elle remplace un programme en cours d'execution par un autre programme.
		 pathname : correspond au chemin absolu ou relatif du programme a executer.
		 argv : un tableau de chaine de caractere qui represente les arguments du programme a executer
		 le premier element est souvent le nom du programme a executer et le dernier est NULL.
		 Exemple : pour executer ls -l, argv serait ["ls", "-l", NULL]
		 envp = un tableau de chaine de caractere representant l environnement du programme a executer, chaques 
		 chaines doivent etre sous la forme clé=valeur : ["PATH=/usr/bin", "HOME=/home/user", NULL]
		 si elle echoue la fonction renvoie -1 qui sera transmissible via errno.
		 Les descripteurs de fichier ouverts dans le programme parent seront transmis dans le programme fils, a moins
		 d'etre fermer avant.
		 les variables d'environnement seront transise via le tableau envp.
		 On combine souvent cette fonction avec fork, fork va cree un processus fils, et execve va permettre d'associer ce
		 processus fils a un executable, exemple, on veux executer ls dans un programme : 
		 on fait un pid_t	pid = fork(); //cree un processus fils.
		 					if (pid == 0)
		 						execve("/bin/ls", argv, envp)   //associe au processus fils l'executable ls.
							else
								wait(NULL);  //attend que le processus fils soit terminer.

Exit : Usage : Permet de sortir d'un programme avec un code de retour
	   Prototype : void exit(int status);
	   Exemple : exit(0);


Fork : Usage : Crée un nouveau processus en dupliquant le processus courant.
				En gros, cela crée un nouveau processus (le fils), qui s'execute apres l'appel de fork simultanement.
				Le retour differe dans le processus parent (PID du fils) et dans le fils(0).
		Prototype : pid_t fork(void);
		Exemple : pid_t pid = fork();
		Dans le processus parent fork retrourne le PID(identifiant de processus) du processus fils.
		Dans le processus fils : fork return 0.
		Si une erreur se produit fork renvoi -1.
		lors d un appel a fork, le processus fils recoit une copie de l'espace memoire du proccessus parent pour pouvoir travailler.
		Cependant, la reelle copie a uniquement lieu quand le fils cherche a faire une modification dynamique.

Pipe : Usage : Crée un pipe(un canal de communication unidirectionnel entre deux processus).
				Crée un canal entre deux processus pour permettre la communication.
	   Prototype : int pipe(int pipefd[2]);
	   Exemple : int pipefd[2];
	   			 pipe(pipefd);
	   Pipe est essentiel car il permet de cree une communication entre deux processus par un mecanisme de tuyau(pipe).
	   pipefd[2] est un tableau de deux descripteur de fichiers.
	   pipefd[0] = descripteur pour lire a partir du pipe.
	   pipefd[1] = descripteur pour ecrire dans le pipe.
	   Si pipe reussit, il return 0 et rempli le tableau pipefd[] avec les deux descripteur de fichiers.
	   En car d erreur pipe return -1, avec son erreur errno associer.
	   pipe est unidirectionnel donc les donnees peuvent circuler uniquement d un sens a la fois.
	   Pipe fonctionne entre deux processus, c'est pour ca que souvent fork est utiliser avec pour pouvoir cree deux processus simultane.
	   Exemple concret pour le projet :
	   si tu veux executer des commandes avec un pipe dans un shell, comme par exemple ls | grep txt, cela 
	   implique la creation de deuc proccessus avec un pipe entre eux :
	   1. Le processus fils 1 executera ls et ecrira dans le pipe.
	   2. le proccessus fils 2 executera grep txt et lira les donnees du pipe.
	   Ce type de mecanisme est realiser en creant un pipe entre les deux processus et en redirigeant les flux entree/sortie.


Unlink : Usage : Supprime un fichier en le retirant du systeme de fichiers
		 Prototype : int unlink(const char *pathname);
		 Exemple : unlink("file.txt");
		 si unlink reussit, return 0, sinon return -1 et errno le capte.
		 Cela desasocie le fichoer de de son nom dans le systeme de fichier mais la suppression ce fera apres que tout 
		 les proccessus utilisant ce fichiers sont fermer.



Pour les fonctions de wait, il faut le header #include <sys/wait.h>
Ces fonctions sont utiliser pour attendre la fin d un processus fils. Elles permettent de recuperer l etat
de terminaison de ses proccessus enfants. Elle sont utile pour la synchrinisation entre proccessus.

Wait : Usage : Permet au processus parent d'attendre la terminaison d'un processus fils.
	   Prototype : pid_t wait(int *status);
	   Exemple : wait(&status);
	   Si le processus fils est terminer avec succes, return PID du fils.
	   Sinon return -1 que errno comprend.
	   status est un pointeur vers un entier dans lequel wait va stocker la code de terminaison du proccessus fils.

Waitpid : Usage : Permet au processus parent d'attendre un processus fils particulier, avec des options pour controler l'attente.
		  Prototype : pid_t waitpid(pid_t pid, int *status, int options);
		  Exemple : waitpid(pid, &status, 0);
		  pid > 0 : Attend la fin du processus dont le PID est pid.
		  pid == 0 : Attend tout les proccessus fils du meme groupe de proccessus.
		  pid == -1 : Attend n importe quel processus fils (equivalent a wait).
		  pid < 1: Attend tout les proccessus fils dont le groupe de processus = |pid|.
		  status = un pointeur vers un entier ou sera stocker le code de terminaison du proccessus.
		  options : Specifie les options pour la fonction waitpid().
		  			0 = Attendre la fin du proccessus fils.
					WNOHANG : Si aucun proccessus fils n a terminer, waitpid retourn immediatement au lieu de bloquer.
					WUNTRACED : Si un processus fils est arrete (pas terminer) la fonction retourne aussi son etat.
		  Si le processus fils est terminer avec succes, return PID du fils.
	      Sinon return -1 que errno comprend.


COMPRENDRE LA COMMANDE A REPLIQUER :

< file1 cmd1 | cmd2 > file2

< file1 = Redirection d'entree : Cela indique que le contenu du fichier file1 sera rediriger comme entree 
								pour la commande suivant (ici cmd1) le contenu du fichier sera lu par
								cmd1 plutoit que l'entree standard.
cmd1 = premiere commande, qui est executee avec le contenu de file1 en entree.

| = Pipe(tuyau) : le caractere | est un pipe qui permet de rediriger la sortie de cmd1 vers l'entree de la
				commande suivante, ici cmd2. Cela signifie que la sortie de cmd1 devient l'entree de cmd2

> file2 = Redirection de sortie : Cela signifie que la sortie de cmd2 sera redirigee vers le fichier file2.
								Cela signifie que la sortie produite par cmd2 (au lieu d'aller dans le terminal) 
								sera ecrite dans le fichier file2.
								- Si file2 existe deja, il sera ecrase par la nouvelle sortie.
								- Si file2 n'existe pas, il sera cree.

Exemple : 
	< file1 grep "example" | wc -l > file2

< file1 : Le contenu de file1 est redirigé en entrée pour la commande grep.
grep "example" : La commande grep recherche le mot "example" dans le contenu de file1.
| wc -l : La sortie de grep (les lignes contenant "example") est envoyée en entrée de wc -l, qui compte le nombre de lignes.
> file2 : Le résultat du comptage de wc -l (le nombre de lignes) est redirigé vers file2.
